<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tricky Turns</n  
>
  <!-- Pi SDK (must load before any Pi.* calls) -->
  <script src="https://sdk.minepi.com/pi-sdk.js" defer></script>

  <!-- Phaser 3 -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js" defer></script>

  <!-- Google Fonts: Poppins -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet" />

  <!-- Styles -->
  <style>
    /* Global Reset & Base Styles */
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(to bottom, #3199E4 0%, #58C0F2 100%);
      position: relative;
    }

    canvas {
      display: block;
      margin: 0 auto;
      visibility: hidden;
      z-index: 1;
    }

    button {
      font-family: inherit;
      cursor: pointer;
      border: none;
      outline: none;
      transition: all 0.2s ease;
    }

    /* Utility Classes */
    .hidden { display: none !important; }
    .flex-center {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Cloud Background Elements */
    .bg-cloud, .start-cloud {
      position: absolute;
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 60'><path d='M20,35 C20,25 35,20 45,25 C50,15 65,15 70,25 C85,25 90,35 80,45 C90,45 95,55 85,60 C75,65 55,60 50,50 C40,60 25,60 20,50 C10,50 5,40 20,35 Z' fill='%23FFFFFF'/></svg>");
      background-size: contain;
      background-repeat: no-repeat;
      filter: blur(6px);
      opacity: 0.8;
      pointer-events: none;
      animation: drift linear infinite;
    }

    .bg-cloud.one,   .start-cloud.one   { width: 260px; height: 90px;  top: 12%;  left: 10%;   animation-duration: 40s; }
    .bg-cloud.two,   .start-cloud.two   { width: 200px; height: 70px;  top:  8%;  right:12%;   animation-duration: 50s; }
    .bg-cloud.three, .start-cloud.three { width: 300px; height:100px;  top: 48%;  left:18%;   animation-duration: 45s; }
    .bg-cloud.four,  .start-cloud.four  { width: 280px; height:95px;   bottom:18%; right:22%;   animation-duration: 55s; }

    @keyframes drift {
      from { transform: translateX(0); }
      to   { transform: translateX(-150vw); }
    }

    /* Buttons */
    .btn-primary {
      background: #3EAFF6;
      color: #fff;
      font-size: 1.4rem;
      font-weight: 700;
      padding: 0.8rem 2.5rem;
      border-radius: 2rem;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
    }
    .btn-primary:hover {
      background: #318EE6;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.3);
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: rgba(255,255,255,0.8);
      color: #000;
      font-size: 0.9rem;
      font-weight: 600;
      padding: 0.2rem 0.6rem;
      border-radius: 0.3rem;
    }
    .btn-secondary:hover { background: rgba(255,255,255,1); }

    /* Responsive Adjustments */
    @media (max-width: 600px) {
      .btn-primary { font-size: 1.1rem; padding: 0.6rem 1.8rem; }
      #start-title { font-size: 3rem; -webkit-text-stroke: 0.4px #0F3D75; }
    }

    /* Screens and Overlays */
    #start-screen,
    #game-over-screen,
    #leaderboard-screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.4);
      z-index: 2;
    }

    #start-screen { background: transparent; cursor: pointer; }

    #start-title {
      color: #fff;
      font-size: 5rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1rem;
      text-align: center;
      line-height: 1.1;
      text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.3);
      -webkit-text-stroke: 0.7px #0F3D75;
    }

    #leaderboard-screen { background: rgba(0,0,0,0.9); overflow-y: auto; padding: 2rem; }
    #leaderboard-entries,
    #leaderboardEntriesHome {
      list-style: none;
      width: 100%; max-width: 400px;
      padding: 0;
      margin: 0;
      color: #fff;
      font-size: 1rem;
    }
    #leaderboard-entries li,
    #leaderboardEntriesHome li {
      position: relative;
      background: rgba(255,255,255,0.05);
      border-radius: 0.4rem;
      margin-bottom: 0.4rem;
      padding: 0.5rem 0.8rem;
      display: flex;
      justify-content: space-between;
    }
    #leaderboard-entries li::before,
    #leaderboardEntriesHome li::before {
      content: attr(data-rank);
      position: absolute;
      left: -2.5rem;
      background: #FF4A4A;
      color: #fff;
      font-weight: 700;
      padding: 0.25rem 0.6rem;
      border-radius: 1rem;
    }

    /* Pause Overlay */
    #pause-overlay {
      position: absolute; inset: 0;
      display: none;
      background: rgba(0,0,0,0.4);
      z-index: 4;
      pointer-events: none;
    }
    #pause-overlay .paused-text {
      font-size: 4rem;
      font-weight: 700;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.1rem;
      -webkit-text-stroke: 1px #000;
    }

    /* Fade Screen for Transitions */
    #fade-screen {
      position: absolute; inset: 0;
      background: #000;
      opacity: 0;
      pointer-events: none;
      z-index: 10;
      transition: opacity 0.6s ease-in-out;
    }
    #fade-screen.fade-in { opacity: 1; }
  </style>
</head>
<body>
  <!-- Clouds -->
  <div class="bg-cloud one"></div>
  <div class="bg-cloud two"></div>
  <div class="bg-cloud three"></div>
  <div class="bg-cloud four"></div>

  <!-- Start Screen -->
  <div id="start-screen">
    <div id="user-info" class="flex-center gap-2 text-white text-shadow">
      <span>User: </span><strong id="username">Guest</strong>
      <button id="loginBtn" class="btn-secondary">Login</button>
    </div>
    <div class="start-cloud one"></div>
    <div class="start-cloud two"></div>
    <div class="start-cloud three"></div>
    <div class="start-cloud four"></div>
    <h1 id="start-title">TRICKY<br />TURNS</h1>
    <button id="startBtn" class="btn-primary">TAP TO START</button>
    <button id="viewLeaderboardBtn" class="btn-primary">VIEW LEADERBOARD</button>
    <div class="orbit">
      <div class="ring"></div>
      <div class="circle top"></div>
      <div class="circle bottom"></div>
    </div>
  </div>

  <!-- Leaderboard Overlay -->
  <div id="leaderboard-screen" class="hidden">
    <button id="closeLeaderboardBtn" class="btn-primary" style="position:absolute;top:1rem;right:1rem;">Close</button>
    <h2 class="text-white">Top 100 Leaderboard</h2>
    <ol id="leaderboardEntriesHome"></ol>
  </div>

  <!-- Pause Overlay -->
  <div id="pause-overlay" class="hidden flex-center"><div class="paused-text">Paused</div></div>

  <!-- Game Over Screen -->
  <div id="game-over-screen" class="hidden flex-center">
    <h2 class="text-red-600 text-6xl uppercase text-shadow">Game Over</h2>
    <div class="result-wrapper relative w-72 h-72">
      <div class="orb-bg absolute inset-0 rounded-full backdrop-filter blur-sm"></div>
      <div class="results absolute inset-0 flex flex-col items-center justify-center text-white uppercase text-2xl font-bold text-shadow">
        <span>SCORE:</span><span id="finalScore">0</span>
        <span>BEST:</span><span id="bestScore">0</span>
      </div>
    </div>
    <button id="restartBtn" class="btn-primary">Restart</button>
    <button id="homeBtn" class="btn-primary">Home</button>
    <ol id="leaderboard-entries"></ol>
  </div>

  <!-- Fade Screen -->
  <div id="fade-screen"></div>

  <!-- Game Script -->
  <script>
    'use strict';

    (async () => {
      // —— Pi Authentication Variables ——
      const scopes = ['username'];
      let piUsername = 'Guest';
      let highScore = 0;
      let useLocalHighScore = true;

      /** Handle incomplete payments */
      function onIncompletePaymentFound(payment) {
        console.warn('Incomplete payment found:', payment);
      }

      /** Initialize Pi Authentication */
      async function initAuth() {
        try {
          const auth = await Pi.authenticate(scopes, onIncompletePaymentFound);
          piUsername = auth.user.username;
          document.getElementById('username').innerText = piUsername;
          document.getElementById('loginBtn').classList.add('hidden');
          useLocalHighScore = false;

          const res = await fetch(`/api/leaderboard/${piUsername}`);
          highScore = res.ok ? (await res.json()).score : 0;
          localStorage.setItem('tricky_high_score', highScore);
        } catch (err) {
          console.info('Not signed in:', err);
        }
      }

      // Attempt silent auth on load
      initAuth();
      // Login button
      document.getElementById('loginBtn').addEventListener('click', initAuth);

      /** Fade helpers */
      function fadeIn(callback, duration = 600) {
        const fade = document.getElementById('fade-screen');
        fade.classList.add('fade-in');
        setTimeout(callback, duration);
      }

      function fadeOut(callback, duration = 600) {
        const fade = document.getElementById('fade-screen');
        fade.classList.remove('fade-in');
        setTimeout(callback, duration);
      }

      /** Show Home Leaderboard */
      async function showHomeLeaderboard() {
        const list = document.getElementById('leaderboardEntriesHome');
        list.innerHTML = '';
        const data = await (await fetch('/api/leaderboard?top=100')).json();
        data.forEach((e, i) => {
          const li = document.createElement('li');
          li.setAttribute('data-rank', `#${i + 1}`);
          li.innerHTML = `<strong>${e.username}</strong><span>${e.score}</span>`;
          list.appendChild(li);
        });
        document.getElementById('leaderboard-screen').classList.remove('hidden');
      }
      document.getElementById('viewLeaderboardBtn').addEventListener('click', showHomeLeaderboard);
      document.getElementById('closeLeaderboardBtn').addEventListener('click', () => {
        document.getElementById('leaderboard-screen').classList.add('hidden');
      });

      // —— Phaser Game Setup ——
      const LANES = [];
      let gameStarted = false;
      let gameOver = false;
      let gamePaused = false;
      let direction = 1;
      let angle = 0;
      let radius = 100;
      let speed = 3;
      const maxSpeed = 6;
      let score = 0;
      let scoreText, pauseIcon, muteIcon, pauseOverlay, countdownText;
      const sfx = {};

      const config = {
        type: Phaser.AUTO,
        transparent: true,
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
        physics: { default: 'arcade', arcade: { debug: false } },
        scene: { preload, create, update }
      };

      window.game = new Phaser.Game(config);

      /** Preload assets */
      function preload() {
        this.load.audio('explode', 'assets/explode.wav');
        this.load.audio('move', 'assets/move.wav');
        this.load.audio('point', 'assets/point.wav');
        this.load.audio('newBest', 'assets/new_best.wav');
        this.load.audio('uiClick', 'assets/ui_click_subtle.wav');
        this.load.audio('pauseWhoosh', 'assets/pause_whoosh_subtle.wav');
      }

      /** Create scene */
      function create() {
        // Cleanup previous groups
        this.obstacles && this.obstacles.clear(true, true);
        this.points && this.points.clear(true, true);

        const cam = this.cameras.main;
        const cx = cam.centerX;
        const cy = cam.centerY;

        // Setup lanes
        LANES[0] = cy - radius;
        LANES[1] = cy;
        LANES[2] = cy + radius;

        // Generate dynamic textures
        createTextures.call(this);

        // Create orbs and physics bodies
        const { circle1, circle2 } = createOrbs.call(this);

        // Create particle trail
        createTrail.call(this, circle1, circle2);

        // Groups for obstacles and points
        this.obstacles = this.physics.add.group();
        this.points = this.physics.add.group();

        // HUD setup
        scoreText = this.add.text(16, 16, 'Score: 0', {
          fontFamily: 'Poppins', fontSize: '36px', color: '#fff', stroke: '#000', strokeThickness: 4
        }).setDepth(2).setVisible(false);

        // Initialize highScore locally for guests
        if (useLocalHighScore) {
          highScore = Number(localStorage.getItem('tricky_high_score')) || 0;
        }

        // UI icons
        pauseIcon = this.add.image(cam.width - 40, 40, 'pauseIcon').setInteractive().setDepth(3).setVisible(false);
        muteIcon = this.add.image(cam.width - 100, 40, 'muteOn').setInteractive().setDepth(3).setVisible(false);
        pauseOverlay = document.getElementById('pause-overlay');

        // Countdown text for resume
        countdownText = this.add.text(cx, cy, '', {
          fontFamily: 'Poppins', fontSize: '96px', color: '#fff', stroke: '#000', strokeThickness: 6
        }).setOrigin(0.5).setDepth(5).setVisible(false);

        // Sound effects
        loadSfx.call(this, sfx);

        // Input handlers
        setupInputHandlers.call(this, circle1, circle2, sfx);

        // Collisions
        this.physics.add.overlap(circle1, this.obstacles, triggerGameOver, null, this);
        this.physics.add.overlap(circle2, this.obstacles, triggerGameOver, null, this);
        this.physics.add.overlap(circle1, this.points, collectPoint, null, this);
        this.physics.add.overlap(circle2, this.points, collectPoint, null, this);

        // Speed ramp timer
        this.time.addEvent({ delay: 1000, loop: true, callback: rampSpeed, callbackScope: this });

        // Object spawn scheduler
        scheduleSpawn.call(this);

        // Start game
        document.getElementById('startBtn').addEventListener('click', () => startGame.call(this, sfx));

        // Restart game
        document.getElementById('restartBtn').addEventListener('click', () => restartGame.call(this, sfx));

        // Home button reload
        document.getElementById('homeBtn').addEventListener('click', () => {
          fadeIn(() => window.location.reload());
        });
      }

      /** Update loop */
      function update() {
        if (!gameStarted || gameOver || gamePaused) return;

        angle += 0.05 * direction;
        updateOrbsPosition.call(this);
        moveEntities.call(this);
      }

      /* ===== Helper Functions ===== */
      function createTextures() {
        const gfx = this.make.graphics({ add: false });
        // Orb base
        gfx.fillStyle(0xffffff, 0.04).fillCircle(50, 50, 30)
           .fillStyle(0xffffff, 1).fillCircle(50, 50, 20)
           .generateTexture('orb', 100, 100).destroy();
        // Obstacle
        gfx.fillStyle(0x0D1B2A, 1).fillRoundedRect(0, 0, 50, 50, 8)
           .generateTexture('obstacle', 50, 50).destroy();
        // Point glow
        gfx.fillStyle(0xffffff, 0.25).fillCircle(40, 40, 40)
           .generateTexture('pointGlow', 80, 80).destroy();
        // Point
        gfx.fillStyle(0xffffff, 1)
           .beginPath().moveTo(25, 0).lineTo(50, 25).lineTo(25, 50).lineTo(0, 25).closePath().fillPath()
           .generateTexture('point', 50, 50).destroy();
        // Controls icons
        gfx.clear().fillStyle(0x000000, 0.3).fillRoundedRect(0, 0, 56, 56, 12)
           .fillStyle(0xffffff, 1).fillRoundedRect(14, 12, 8, 32, 4).fillRoundedRect(34, 12, 8, 32, 4)
           .generateTexture('pauseIcon', 56, 56).destroy();
        gfx.clear().fillStyle(0x000000, 0.3).fillRoundedRect(0, 0, 56, 56, 12)
           .fillStyle(0xffffff, 1).fillTriangle(20, 16, 20, 40, 40, 28)
           .generateTexture('playIcon', 56, 56).destroy();
        gfx.clear().fillStyle(0x000000, 0.3).fillRoundedRect(0, 0, 56, 56, 12)
           .fillStyle(0xffffff, 1).fillRect(16, 18, 8, 20)
           .beginPath().moveTo(24, 18).lineTo(38, 8).lineTo(38, 52).lineTo(24, 32).closePath().fillPath()
           .generateTexture('muteOn', 56, 56).destroy();
        gfx.clear().fillStyle(0x000000, 0.3).fillRoundedRect(0, 0, 56, 56, 12)
           .fillStyle(0xffffff, 1).fillRect(16, 18, 8, 20)
           .lineStyle(4, 0xffffff, 1).beginPath().moveTo(20, 20).lineTo(44, 44).strokePath()
           .beginPath().moveTo(44, 20).lineTo(20, 44).strokePath()
           .generateTexture('muteOff', 56, 56).destroy();
      }

      function createOrbs() {
        const circle1 = this.add.image(0, 0, 'orb'); this.physics.add.existing(circle1);
        circle1.body.setCircle(22.5, 27.5, 27.5);
        const circle2 = this.add.image(0, 0, 'orb'); this.physics.add.existing(circle2);
        circle2.body.setCircle(22.5, 27.5, 27.5);
        return { circle1, circle2 };
      }

      function createTrail(circle1, circle2) {
        const trail = this.add.particles('orb');
        [circle1, circle2].forEach(c => {
          trail.createEmitter({ follow: c, lifespan: 300, scale: { start: 0.3, end: 0 }, alpha: { start: 0.4, end: 0 }, frequency: 50, blendMode: 'ADD' });
        });
      }

      function loadSfx(sfx) {
        sfx.explode     = this.sound.add('explode');
        sfx.move        = this.sound.add('move');
        sfx.point       = this.sound.add('point');
        sfx.newBest     = this.sound.add('newBest');
        sfx.uiClick     = this.sound.add('uiClick');
        sfx.pauseWhoosh = this.sound.add('pauseWhoosh');
      }

      function setupInputHandlers(circle1, circle2, sfx) {
        // Rotation on tap
        this.input.on('pointerdown', () => {
          if (gameStarted && !gameOver && !gamePaused) {
            direction *= -1;
            sfx.move.play();
            this.tweens.add({ targets: [circle1, circle2], scaleX: 1.15, scaleY: 1.15, yoyo: true, duration: 100, ease: 'Quad.easeInOut' });
          }
        });

        // Pause/Play toggle
        pauseIcon.on('pointerdown', (pointer, x, y, event) => {
          event.stopPropagation();
          if (!gameStarted || gameOver) return;
          togglePause.call(this, sfx);
        });

        // Mute toggle
        muteIcon.on('pointerdown', () => {
          this.sound.mute = !this.sound.mute;
          muteIcon.setTexture(this.sound.mute ? 'muteOff' : 'muteOn');
          if (!this.sound.mute) sfx.uiClick.play();
        });
      }

      function togglePause(sfx) {
        gamePaused = !gamePaused;
        if (gamePaused) {
          pauseIcon.setTexture('playIcon');
          sfx.pauseWhoosh.play();
          this.physics.pause();
          pauseOverlay.style.display = 'flex';
        } else {
          resumeCountdown.call(this, sfx);
        }
      }

      function resumeCountdown(sfx) {
        let count = 3;
        sfx.pauseWhoosh.play();
        countdownText.setText(count).setVisible(true);
        this.time.addEvent({ delay: 1000, repeat: 2, callback: () => {
          count--;
          if (count > 0) {
            countdownText.setText(count);
          } else {
            countdownText.setVisible(false);
            gamePaused = false;
            pauseIcon.setTexture('pauseIcon');
            this.physics.resume();
            pauseOverlay.style.display = 'none';
          }
        }});
      }

      function rampSpeed() {
        if (!gameStarted || gameOver || gamePaused) return;
        speed += speed > 1.5 ? 0.006 : (speed >= 1.2 ? 0.0015 : 0);
      }

      function getSpawnInterval() {
        const t = Phaser.Math.Clamp((speed - 3) / (maxSpeed - 3), 0, 1);
        return Phaser.Math.Linear(1500, 500, t);
      }

      function scheduleSpawn() {
        this.time.delayedCall(getSpawnInterval(), () => {
          if (gameStarted && !gameOver && !gamePaused) spawnObjects.call(this);
          scheduleSpawn.call(this);
        });
      }

      function spawnObjects() {
        const y = Phaser.Math.RND.pick(LANES);
        const fromLeft = Phaser.Math.Between(0, 1) === 0;
        const x = fromLeft ? -50 : this.cameras.main.width + 50;
        const vx = (fromLeft ? speed : -speed) * 60;

        if (Phaser.Math.Between(1, 100) <= 35) {
          this.add.image(x, y, 'pointGlow').setDepth(1).setBlendMode('ADD');
          const p = this.physics.add.image(x, y, 'point').setDepth(2);
          p.body.setSize(50,50).setOffset(-25,-25).setVelocityX(vx);
          this.points.add(p);
        } else {
          const o = this.physics.add.image(x, y, 'obstacle').setDepth(1);
          o.body.setSize(50,50).setOffset(-25,-25).setVelocityX(vx).setImmovable(true);
          this.obstacles.add(o);
        }
      }

      function updateOrbsPosition() {
        const o1 = Phaser.Math.Vector2.RIGHT.clone().rotate(angle).scale(radius);
        const o2 = Phaser.Math.Vector2.RIGHT.clone().rotate(angle + Math.PI).scale(radius);
        const center = this.cameras.main.center;
        this.circle1?.setPosition(center.x + o1.x, center.y + o1.y);
        this.circle2?.setPosition(center.x + o2.x, center.y + o2.y);
      }

      function moveEntities() {
        this.obstacles.getChildren().forEach(o => o.x -= speed);
        this.points.getChildren().forEach(p => p.x -= speed);
      }

      function triggerGameOver(circle, entity) {
        if (gameOver) return;
        gameOver = true;
        explodeOrbs.call(this, circle);
        sfx.explode.play();
        this.time.delayedCall(700, finalizeGameOver.bind(this));
      }

      function explodeOrbs(circle) {
        const particles = this.add.particles('orb');
        [this.circle1, this.circle2].forEach(c => {
          if (!c) return;
          particles.createEmitter({
            x: c.x, y: c.y,
            speed: { min: 150, max: 350 },
            angle: { min: 0, max: 360 },
            scale: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            quantity: 8
          });
          c.destroy();
        });
      }

      function finalizeGameOver() {
        this.physics.pause();
        document.querySelector('canvas').style.visibility = 'hidden';
        document.getElementById('finalScore').innerText = score;
        if (score > highScore) {
          highScore = score;
          sfx.newBest.play();
        }
        document.getElementById('bestScore').innerText = highScore;

        // Persist high score
        if (useLocalHighScore) {
          localStorage.setItem('tricky_high_score', highScore);
        } else {
          fetch('/api/leaderboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username: piUsername, score: highScore })
          }).catch(console.error);
        }

        // Show top 100 leaderboard on game over screen
        fetch('/api/leaderboard?top=100')
          .then(res => res.json())
          .then(data => {
            const list = document.getElementById('leaderboard-entries');
            list.innerHTML = '';
            data.forEach((e, i) => {
              const li = document.createElement('li');
              li.setAttribute('data-rank', `#${i + 1}`);
              li.innerHTML = `<strong>${e.username}</strong><span>${e.score}</span>`;
              list.appendChild(li);
            });
          })
          .catch(console.error);

        document.getElementById('game-over-screen').classList.remove('hidden');
      }

      function collectPoint(circle, point) {
        point.destroy();
        score++;
        sfx.point.play();
        scoreText.setText(`Score: ${score}`);
        this.tweens.add({ targets: scoreText, scaleX: 1.1, scaleY: 1.1, yoyo: true, duration: 80, ease: 'Sine.easeOut' });
      }

      function startGame(sfx) {
        sfx.uiClick.play();
        fadeIn(() => {
          document.getElementById('start-screen').classList.add('hidden');
          document.getElementById('user-info').classList.add('hidden');
          canvas.style.visibility = 'visible';
          scoreText.setVisible(true);
          pauseIcon.setVisible(true);
          muteIcon.setVisible(true);
          gameStarted = true;
          scheduleSpawn.call(this);
          fadeOut();
        });
      }

      function restartGame(sfx) {
        sfx.uiClick.play();
        fadeIn(() => {
          this.scene.restart();
          Object.assign(window, { gameStarted: false, gameOver: false, gamePaused: false, direction: 1, angle: 0, speed: 3, score: 0 });
          fadeOut(() => {
            scoreText.setText('Score: 0').setVisible(true);
            pauseIcon.setVisible(true);
            gameStarted = true;
            scheduleSpawn.call(this);
          });
        });
      }
    })();
  </script>
</body>
</html>
