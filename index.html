<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://sdk.minepi.com/pi-sdk.js"></script>
  <script>Pi.init({ version: "2.0", sandbox: true });</script>
  <meta charset="utf-8"/>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <title>Tricky Turns</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
    /* ...all CSS unchanged... */
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { width:100%; height:100%; overflow:hidden; }
    body { font-family:'Poppins',sans-serif; background: linear-gradient(to bottom, #3199E4 0%, #58C0F2 100%); position:relative; }
    canvas { display:block; margin:0 auto; visibility:hidden; z-index:1; }
    /* ...the rest of your styles from before... */
    #leaderboard, #leaderboardEntriesHome, #leaderboard-screen ol {
      width: 100%;
      max-width: 400px;
      box-sizing: border-box;
      margin: 0 auto;
      padding-left: 2.5rem;
      background:rgba(0,0,0,0.6);
      padding-top:1rem; padding-bottom:1rem; border-radius:0.5rem;
      max-height:300px; overflow-y:auto;
      color:#fff; font-size:1rem;
      text-align:left; line-height:1.4;
    }
    #fade-screen {
      position: absolute; inset: 0;
      background: #000; opacity: 0; pointer-events: none; z-index: 10;
      transition: opacity 0.6s ease-in-out;
    }
    #fade-screen.fade-in { opacity: 1; }
  </style>
</head>
<body>
  <div class="bg-cloud one"></div>
  <div class="bg-cloud two"></div>
  <div class="bg-cloud three"></div>
  <div class="bg-cloud four"></div>
  <div id="start-screen">
    <div id="user-info">User: <strong id="username">Guest</strong>
      <button class="btn-secondary" id="loginBtn">Login</button>
    </div>
    <div class="start-cloud one"></div>
    <div class="start-cloud two"></div>
    <div class="start-cloud three"></div>
    <div class="start-cloud four"></div>
    <h1>TRICKY<br/>TURNS</h1>
    <button class="btn-primary" id="startBtn">TAP TO START</button>
    <button class="btn-primary" id="viewLeaderboardBtn">VIEW LEADERBOARD</button>
    <div class="orbit">
      <div class="ring"></div>
      <div class="circle top"></div>
      <div class="circle bottom"></div>
    </div>
  </div>
  <div id="leaderboard-screen">
    <button class="btn-primary" id="closeLeaderboardBtn">Close</button>
    <h2>Top 100 Leaderboard</h2>
    <ol id="leaderboardEntriesHome"></ol>
  </div>
  <div id="pause-overlay"><div class="paused-text">Paused</div></div>
  <div id="game-over-screen">
    <h1>GAME OVER</h1>
    <div class="result-wrapper">
      <div class="orb-bg" style="display:none;"></div>
      <div class="results" style="color: #fff; font-size: 2rem; font-weight: 600; text-align: center;text-shadow: 0 0 4px #000; text-transform: uppercase;">
        SCORE: <span id="finalScore">0</span><br/>
        BEST: <span id="bestScore">0</span>
      </div>
    </div>
    <button class="btn-primary" id="restartBtn">RESTART</button>
    <button class="btn-primary" id="homeBtn">HOME</button>
  </div>
  <div id="fade-screen"></div>
  <script>
    // ---- Pi Auth, leaderboard, and fade logic unchanged ----
    const scopes = ['username'];
    let piUsername = 'Guest', highScore = 0, useLocalHighScore = true;
    function onIncompletePaymentFound(payment) { console.log('Incomplete payment found:', payment);}
    async function initAuth() {
      try {
        const auth = await Pi.authenticate(scopes, onIncompletePaymentFound);
        piUsername = auth.user.username;
        document.getElementById('username').innerText = piUsername;
        document.getElementById('loginBtn').style.display = 'none';
        useLocalHighScore = false;
        const res = await fetch(`/api/leaderboard/${piUsername}`);
        if (res.ok) { const entry = await res.json(); highScore = entry.score; } else { highScore = 0; }
        localStorage.setItem('tricky_high_score', highScore);
      } catch (e) {}
    }
    initAuth();
    document.getElementById('loginBtn').addEventListener('click', initAuth);
    function fadeIn(callback, duration = 600) {
      const fade = document.getElementById('fade-screen');
      fade.classList.add('fade-in'); setTimeout(() => { callback?.(); }, duration);
    }
    function fadeOut(callback, duration = 600) {
      const fade = document.getElementById('fade-screen');
      fade.classList.remove('fade-in'); setTimeout(() => { callback?.(); }, duration);
    }
    async function showHomeLeaderboard() {
      const list = document.getElementById('leaderboardEntriesHome');
      list.innerHTML = '';
      const data = await fetch('/api/leaderboard?top=100').then(r=>r.json());
      data.forEach((e, i) => {
        const li = document.createElement('li');
        li.setAttribute('data-rank', `#${i + 1}`);
        li.innerHTML = `<strong>${e.username}</strong><span>${e.score}</span>`;
        list.appendChild(li);
      });
      document.getElementById('leaderboard-screen').style.display = 'flex';
    }
    document.getElementById('viewLeaderboardBtn').addEventListener('click', showHomeLeaderboard);
    document.getElementById('closeLeaderboardBtn').addEventListener('click', ()=>{
      document.getElementById('leaderboard-screen').style.display = 'none';
    });

    // --- Only these are global ---
    let gameStarted = false, gameOver = false, gamePaused = false;
    let direction = 1, angle = 0, radius = 100, speed = 3, maxSpeed = 6;
    let score = 0, sfx = {}, isMuted = false;

    // -- Phaser scene --
    const config = {
      type: Phaser.AUTO,
      transparent: true,
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      physics: { default: 'arcade', arcade: { debug: false } },
      scene: { key: 'default', preload, create, update }
    };
    window.game = new Phaser.Game(config);

    function preload() {
      this.load.audio('explode','assets/explode.wav');
      this.load.audio('move','assets/move.wav');
      this.load.audio('point','assets/point.wav');
      this.load.audio('newBest','assets/new_best.wav');
      this.load.audio('uiClick','assets/ui_click_subtle.wav');
      this.load.audio('pauseWhoosh','assets/pause_whoosh_subtle.wav');
    }

    function create() {
      // Only manage Phaser HUD/objects here!
      this.LANES = [];
      gameStarted = true; gameOver = false; gamePaused = false; direction = 1; angle = 0; speed = 3; score = 0;
      const cam = this.cameras.main;
      const cx = cam.centerX, cy = cam.centerY;
      this.LANES[0] = cy - radius; this.LANES[1] = cy; this.LANES[2] = cy + radius;

      this.make.graphics({add:false})
        .fillStyle(0xffffff,0.04).fillCircle(50,50,30)
        .fillStyle(0xffffff,1).fillCircle(50,50,20)
        .generateTexture('orb',100,100).destroy();
      this.make.graphics({add:false})
        .fillStyle(0x0D1B2A,1).fillRoundedRect(0,0,50,50,8)
        .generateTexture('obstacle',50,50).destroy();
      this.make.graphics({add:false})
        .fillStyle(0xffffff,0.25).fillCircle(40,40,40)
        .generateTexture('pointGlow',80,80).destroy();
      this.make.graphics({add:false})
        .fillStyle(0xffffff,1)
        .beginPath().moveTo(25,0).lineTo(50,25).lineTo(25,50).lineTo(0,25)
        .closePath().fillPath()
        .generateTexture('point',50,50).destroy();

      this.circle1 = this.add.image(0,0,'orb'); this.physics.add.existing(this.circle1);
      this.circle1.body.setCircle(22.5,27.5,27.5);
      this.circle2 = this.add.image(0,0,'orb'); this.physics.add.existing(this.circle2);
      this.circle2.body.setCircle(22.5,27.5,27.5);

      const trail = this.add.particles('orb');
      [this.circle1,this.circle2].forEach(c => trail.createEmitter({
        follow:c, lifespan:300, speed:0,
        scale:{start:0.3,end:0}, alpha:{start:0.4,end:0},
        frequency:50, blendMode:'ADD'
      }));

      this.obstacles = this.physics.add.group();
      this.points = this.physics.add.group();

      this.scoreText = this.add.text(16,16,'Score: 0',{
        fontFamily:'Poppins', fontSize:'36px',
        color:'#fff', stroke:'#000', strokeThickness:4
      }).setDepth(2).setVisible(true);

      if (useLocalHighScore) highScore = Number(localStorage.getItem('tricky_high_score')) || 0;

      const gfx = this.make.graphics({add:false});
      gfx.fillStyle(0x000000,0.3).fillRoundedRect(0,0,56,56,12)
         .fillStyle(0xffffff,1).fillRoundedRect(14,12,8,32,4).fillRoundedRect(34,12,8,32,4);
      gfx.generateTexture('pauseIcon',56,56);
      gfx.clear().fillStyle(0x000000,0.3).fillRoundedRect(0,0,56,56,12)
         .fillStyle(0xffffff,1).fillTriangle(20,16,20,40,40,28);
      gfx.generateTexture('playIcon',56,56);
      gfx.clear().fillStyle(0x000000,0.3).fillRoundedRect(0,0,56,56,12)
         .fillStyle(0xffffff,1).fillRect(16,18,8,20)
         .beginPath().moveTo(24,18).lineTo(38,8).lineTo(38,52).lineTo(24,32).closePath().fillPath();
      gfx.generateTexture('muteOn',56,56);
      gfx.clear().fillStyle(0x000000,0.3).fillRoundedRect(0,0,56,56,12)
         .fillStyle(0xffffff,1).fillRect(16,18,8,20)
         .beginPath().moveTo(24,18).lineTo(38,8).lineTo(38,52).lineTo(24,32).closePath().fillPath()
         .lineStyle(4,0xffffff,1).beginPath().moveTo(20,20).lineTo(44,44).strokePath()
         .beginPath().moveTo(44,20).lineTo(20,44).strokePath();
      gfx.generateTexture('muteOff',56,56);

      this.pauseIcon = this.add.image(cam.width-40,40,'pauseIcon')
                    .setInteractive().setDepth(3).setVisible(true);
      const muteIcon = this.add.image(cam.width-100,40,'muteOn')
                       .setInteractive().setDepth(3).setVisible(true);
      pauseOverlay = document.getElementById('pause-overlay');
      this.countdownText = this.add.text(cx,cy,'',{
        fontFamily:'Poppins', fontSize:'96px',
        color:'#fff', stroke:'#000', strokeThickness:6
      }).setOrigin(0.5).setDepth(5).setVisible(false);
      sfx.explode     = this.sound.add('explode');
      sfx.move        = this.sound.add('move');
      sfx.point       = this.sound.add('point');
      sfx.newBest     = this.sound.add('newBest');
      sfx.uiClick     = this.sound.add('uiClick');
      sfx.pauseWhoosh = this.sound.add('pauseWhoosh');

      muteIcon.on('pointerdown',()=>{
        isMuted=!isMuted;
        this.sound.mute=isMuted;
        muteIcon.setTexture(isMuted?'muteOff':'muteOn');
        if(!isMuted) sfx.uiClick.play();
      });

      this.pauseIcon.on('pointerdown',(_,x,y,e)=>{
        e.stopPropagation();
        if(!gameStarted||gameOver) return;
        if(!gamePaused){
          gamePaused=true;
          this.pauseIcon.setTexture('playIcon');
          sfx.pauseWhoosh.play();
          this.physics.pause();
          pauseOverlay.style.display='flex';
        } else {
          sfx.pauseWhoosh.play();
          let count=3;
          this.countdownText.setText(count).setVisible(true);
          this.time.addEvent({
            delay:1000, repeat:2,
            callback: ()=>{
              count--;
              if(count>0) this.countdownText.setText(count);
              else {
                this.countdownText.setVisible(false);
                gamePaused=false;
                this.pauseIcon.setTexture('pauseIcon');
                this.physics.resume();
                pauseOverlay.style.display='none';
              }
            }
          });
        }
      });

      this.input.on('pointerdown',()=>{
        if(gameStarted&&!gameOver&&!gamePaused){
          direction*=-1;
          sfx.move.play();
          this.tweens.add({
            targets:[this.circle1,this.circle2],
            scaleX:1.15, scaleY:1.15,
            yoyo:true, duration:100, ease:'Quad.easeInOut'
          });
        }
      });

      this.physics.add.overlap(this.circle1,this.obstacles,triggerGameOver,null,this);
      this.physics.add.overlap(this.circle2,this.obstacles,triggerGameOver,null,this);
      this.physics.add.overlap(this.circle1,this.points,collectPoint,null,this);
      this.physics.add.overlap(this.circle2,this.points,collectPoint,null,this);

      this.time.addEvent({
        delay:1000, loop:true,
        callback: ()=>{
          if(gameStarted&&!gameOver&&!gamePaused){
            if(speed>1.5) speed+=0.006;
            else if(speed>=1.2) speed+=0.0015;
          }
        }
      });

      const scene=this;
      function getSpawnInterval(){
        const t=Phaser.Math.Clamp((speed-3)/(maxSpeed-3),0,1);
        return Phaser.Math.Linear(1500,500,t);
      }
      function scheduleSpawn(){
        scene.time.delayedCall(getSpawnInterval(),()=>{
          if(gameStarted&&!gameOver&&!gamePaused) spawnObjects.call(scene);
          scheduleSpawn();
        },[],scene);
      }
      scheduleSpawn();
    }

    function update(){
      if(!gameStarted||gameOver||gamePaused) return;
      const scene = this;
      angle+=0.05*direction;
      const o1=Phaser.Math.Vector2.RIGHT.clone().rotate(angle).scale(radius);
      const o2=Phaser.Math.Vector2.RIGHT.clone().rotate(angle+Math.PI).scale(radius);
      if(scene.circle1 && scene.circle2) {
        scene.circle1.setPosition(scene.cameras.main.centerX+o1.x,scene.cameras.main.centerY+o1.y);
        scene.circle2.setPosition(scene.cameras.main.centerX+o2.x,scene.cameras.main.centerY+o2.y);
      }
      if(scene.obstacles) scene.obstacles.children.iterate(o=>o.x-=speed);
      if(scene.points) scene.points.children.iterate(p=>p.x-=speed);
    }

    function spawnObjects(){
      const scene = this;
      const y=Phaser.Math.RND.pick(scene.LANES);
      const fromLeft=Phaser.Math.Between(0,1)===0;
      const x=fromLeft?-50:scene.cameras.main.width+50;
      const vx=(fromLeft?speed:-speed)*60;
      if(Phaser.Math.Between(1,100)<=35){
        scene.add.image(x,y,'pointGlow').setDepth(1).setBlendMode('ADD');
        const p=scene.physics.add.image(x,y,'point').setDepth(2);
        p.body.setSize(50,50).setOffset(-25,-25).setVelocityX(vx);
        scene.points.add(p);
      } else {
        const o=scene.physics.add.image(x,y,'obstacle').setDepth(1);
        o.body.setSize(50,50).setOffset(-25,-25).setImmovable(true).setVelocityX(vx);
        scene.obstacles.add(o);
      }
    }

    function triggerGameOver(player, obstacle){
      if(gameOver) return;
      const scene = this;
      gameOver=true;
      [scene.circle1,scene.circle2].forEach(c=>{
        if(c){
          const px=c.x, py=c.y; c.destroy();
          scene.add.particles('orb').createEmitter({
            x:px,y:py,
            speed:{min:150,max:350},
            angle:{min:0,max:360},
            scale:{start:0.8,end:0},
            lifespan:500,blendMode:'ADD',quantity:8
          });
        }
      });
      sfx.explode.play();
      scene.time.delayedCall(700,()=>{
        scene.physics.pause();
        document.querySelector('canvas').style.visibility='hidden';
        document.getElementById('finalScore').innerText=score;
        if(score > highScore){
          highScore = score;
          sfx.newBest.play();
        }
        document.getElementById('bestScore').innerText = highScore;
        if(useLocalHighScore) localStorage.setItem('tricky_high_score', highScore);
        if (!useLocalHighScore) {
          fetch('/api/leaderboard', {
            method:'POST',
            headers:{ 'Content-Type':'application/json' },
            body: JSON.stringify({ username: piUsername, score: highScore })
          }).catch(console.error);
        }
        document.getElementById('game-over-screen').style.display='flex';
      });
    }

    function collectPoint(_,pt){
      const scene = this;
      pt.destroy();
      score++;
      sfx.point.play();
      scene.scoreText.setText('Score: '+score);
      scene.tweens.add({
        targets:scene.scoreText,
        scaleX:1.1, scaleY:1.1,
        yoyo:true, duration:80, ease:'Sine.easeOut'
      });
    }

    // DOM Events
    document.getElementById('startBtn').addEventListener('click', ()=>{
      sfx.uiClick?.play();
      document.getElementById('user-info').style.display='none';
      document.getElementById('viewLeaderboardBtn').style.display='none';
      document.getElementById('start-screen').style.display='none';
      document.querySelector('canvas').style.visibility='visible';
      // Start the game!
      game.scene.keys.default.scene.restart();
    });
    document.getElementById('restartBtn').addEventListener('click', () => {
      sfx.uiClick?.play();
      document.getElementById('game-over-screen').style.display = 'none';
      document.querySelector('canvas').style.visibility='visible';
      window.game.scene.keys.default.scene.restart();
    });
    document.getElementById('homeBtn').addEventListener('click', () => {
      fadeIn(() => window.location.href = window.location.href);
    });
  </script>
</body>
</html>
